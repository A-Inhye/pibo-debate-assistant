# 1월 20일 개발일지 - RealtimeSTT + Diart 화자 분할 통합

## 목표
`realtime_stt_korean.py`에 Diart 기반 화자 분할을 추가하여 실시간 STT + 화자 구분 기능 구현

---

## 생성된 파일

| 파일 | 설명 |
|------|------|
| `realtime_stt_korean_diart.py` | 콘솔 출력만 (웹 연동 X) |
| `realtime_stt_korean_diart_web.py` | 웹 연동 버전 (WebSocket 포함) |

---

## 해결한 문제들

### 1. 다른 컴퓨터에서 실행 가능하도록 경로 수정

**문제:** 절대 경로가 하드코딩되어 다른 컴퓨터에서 실행 불가

**해결:** 상대 경로로 변경
```python
# 변경 전
diart_path = "C:/Users/SEC/src_pibo/real_time_STT/diart-main/diart-main/src"

# 변경 후
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
diart_path = os.path.join(SCRIPT_DIR, "diart-main", "diart-main", "src")
```

---

### 2. cuDNN 오류 해결

**오류:** `Could not load symbol cudnnGetLibConfig. Error code 127`

**원인:** CUDA/cuDNN 라이브러리 경로 불일치

**해결:** 코드 상단에 DLL 경로 설정 추가
```python
# Windows에서 cuDNN/cuBLAS DLL 경로 설정 (CUDA 오류 방지)
if os.name == 'nt':  # Windows
    try:
        import nvidia.cublas.lib
        import nvidia.cudnn.lib
        os.add_dll_directory(os.path.dirname(nvidia.cublas.lib.__file__))
        os.add_dll_directory(os.path.dirname(nvidia.cudnn.lib.__file__))
    except (ImportError, OSError):
        pass
```

---

### 3. PyTorch 2.6 weights_only 오류 해결

**오류:** `Weights only load failed. This file can still be loaded...`

**원인:** PyTorch 2.6에서 `torch.load`의 `weights_only` 기본값이 `True`로 변경됨

**해결:** PyTorch 2.5.1로 다운그레이드
```powershell
pip uninstall torch torchvision torchaudio -y
pip install torch==2.5.1 torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118
```

**추가 대응 코드 (코드에 포함됨):**
```python
# 방법 1: safe_globals에 TorchVersion 추가
try:
    torch.serialization.add_safe_globals([torch.torch_version.TorchVersion])
except (AttributeError, TypeError):
    pass

# 방법 2: torch.load 패치
_original_torch_load = torch.load
def _patched_torch_load(*args, **kwargs):
    kwargs.setdefault('weights_only', False)
    return _original_torch_load(*args, **kwargs)
torch.load = _patched_torch_load

# 방법 3: 환경 변수 설정
os.environ['TORCH_FORCE_WEIGHTS_ONLY_LOAD'] = '0'
```

---

### 4. bytearray 타입 처리 오류 해결

**오류:** `AttributeError: 'bytearray' object has no attribute 'dtype'`

**원인:** RealtimeSTT가 `bytearray`로 오디오 청크를 전달하는데, 코드에서 `bytes`만 처리

**해결:**
```python
# 변경 전
if isinstance(audio_chunk, bytes):
    audio_chunk = np.frombuffer(audio_chunk, dtype=np.int16)

# 변경 후
if isinstance(audio_chunk, (bytes, bytearray)):
    audio_chunk = np.frombuffer(audio_chunk, dtype=np.int16)

if hasattr(audio_chunk, 'dtype') and audio_chunk.dtype == np.int16:
    audio_chunk = audio_chunk.astype(np.float32) / 32768.0
```

---

### 5. import 순서 문제

**문제:** `torch.load` 패치가 적용되지 않음

**원인:** `from RealtimeSTT import AudioToTextRecorder`가 먼저 실행되면서 torch가 이미 로드됨

**해결:** import 순서 변경
```python
# 1. sys, os 먼저 import
import sys
import os

# 2. DLL 경로 설정
if os.name == 'nt':
    ...

# 3. torch import 및 패치
import torch
_original_torch_load = torch.load
...
torch.load = _patched_torch_load

# 4. 나머지 모듈 import (이제 패치된 torch.load 사용)
from RealtimeSTT import AudioToTextRecorder
```

---

## 실행 방법

### 콘솔 버전
```powershell
cd "C:\Users\User\pibo\1월 21일"
python realtime_stt_korean_diart.py
```

### 웹 연동 버전
```powershell
# 터미널 1 - 웹 서버
cd "C:\Users\User\pibo"
python -m http.server 8000

# 터미널 2 - STT + 화자 분할
cd "C:\Users\User\pibo\1월 21일"
python realtime_stt_korean_diart_web.py

# 브라우저에서 열기
http://localhost:8000/index.html
```

---

## 필요한 폴더 구조

```
pibo/ (또는 real_time_STT/)
├── 1월 21일/
│   ├── realtime_stt_korean_diart.py
│   ├── realtime_stt_korean_diart_web.py
│   └── 1월 20일 개발일지.md
├── diart-main/
│   └── diart-main/
│       └── src/
└── index.html
```

---

## 필요한 패키지

```powershell
# PyTorch 2.5.1 (2.6은 오류 발생)
pip install torch==2.5.1 torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118

# 기타 패키지
pip install pyannote.audio einops websockets RealtimeSTT pyaudio
```

---

## 참고 링크 (오류 해결에 도움됨)

- https://huggingface.co/mistralai/Voxtral-Mini-3B-2507/discussions/23
- https://github.com/JaidedAI/EasyOCR/issues/833
- https://github.com/opendatalab/MinerU/issues/2664

---

## 추가 작업 (1월 21일 새벽)

### SEC 노트북에서 새 가상환경 설정

#### 1. 가상환경 생성
```powershell
conda create -n pibopibo python=3.11
conda activate pibopibo
```

#### 2. 패키지 설치 (한 줄)
```powershell
pip install torch==2.5.1 torchvision torchaudio --index-url https://download.pytorch.org/whl/cu118; pip install pyannote.audio einops websockets RealtimeSTT pyaudio
```

**주의:** `pyannote.audio`가 자동으로 torch 2.8.0을 설치할 수 있음

#### 3. pyannote.audio 버전 충돌 해결
```powershell
# pyannote.audio 4.0.3은 torch 2.8.0 요구 → 오류 발생
# pyannote.audio 3.3.2는 torch 2.5.1과 호환됨
pip install pyannote.audio==3.3.2
```

#### 4. PyTorch 다시 다운그레이드 (필요시)
```powershell
pip install torch==2.5.1 torchvision==0.20.1 torchaudio==2.5.1 --index-url https://download.pytorch.org/whl/cu118
```

#### 5. 의존성 충돌 확인
```powershell
pip check
# "No broken requirements found." 가 나오면 OK
```

#### 6. 설치된 버전 확인
```powershell
pip show torch pyannote.audio
```

**정상 설치 결과:**
| 패키지 | 버전 |
|--------|------|
| torch | 2.5.1+cu118 |
| pyannote.audio | 3.3.2 |

---

### 최종 설치 명령어 (권장 순서)

새 가상환경에서 처음부터 설치할 때:

```powershell
# 1. PyTorch 먼저 설치 (cu118 버전)
pip install torch==2.5.1 torchvision==0.20.1 torchaudio==2.5.1 --index-url https://download.pytorch.org/whl/cu118

# 2. pyannote.audio 3.3.2 설치 (torch 2.5.1 호환)
pip install pyannote.audio==3.3.2

# 3. 나머지 패키지 설치
pip install einops websockets RealtimeSTT pyaudio

# 4. 의존성 확인
pip check
```

---

### 테스트 결과

- **User 컴퓨터 (원격):** 화자 분할 + STT 동작 확인 (마이크 테스트는 내일)
- **SEC 노트북:** 패키지 설치 완료, 테스트 예정

---

## 프로젝트 구조 요약

```
[RealtimeSTT] ──음성인식──→ 텍스트
      │
      │ on_recorded_chunk (오디오 청크)
      ▼
[Diart/pyannote] ──화자분할──→ 화자 라벨 (화자 A, B, C...)
      │
      ▼
[WebSocket 서버] ──전송──→ [웹 브라우저 index.html]
```

---

## 핵심 정리

| 항목 | 내용 |
|------|------|
| **PyTorch 버전** | 2.5.1+cu118 (2.6 이상 사용 금지) |
| **pyannote.audio 버전** | 3.3.2 (4.x는 torch 2.8 요구) |
| **WebSocket 포트** | 9090 |
| **웹서버 포트** | 8000 |
| **화자 구분** | 최대 10명 |

---

## 다음 할 일

- [x] 외장 마이크 (Jabra Speak2 75) 연결 후 테스트
- [x] SEC 노트북에서 가상환경 설정 완료
- [x] SEC 노트북에서 실제 실행 테스트

---

## 추가 작업 (1월 21일 오전)

### 수정한 파일

| 파일 | 경로 |
|------|------|
| 메인 코드 | `C:\Users\SEC\src_pibo\real_time_STT\realtime_stt_korean_diart_web.py` |
| 개발일지 | `C:\Users\SEC\src_pibo\real_time_STT\1월 21일\1월 20일 개발일지.md` |

---

### SEC 노트북에서 DLL 오류 해결

#### 1. cudnn_ops_infer64_8.dll 오류

**오류:** `Could not locate cudnn_ops_infer64_8.dll`

**원인:** nvidia-cudnn-cu11 최신 버전(9.x)에는 cuDNN 9 DLL만 포함됨. ctranslate2는 cuDNN 8 필요.

**해결:**
```powershell
# cuDNN 8 버전 설치
pip install nvidia-cudnn-cu11==8.9.5.29

# DLL을 ctranslate2 폴더에 복사
Copy-Item "C:\Users\SEC\anaconda3\envs\pibopibo\Lib\site-packages\nvidia\cudnn\bin\cudnn_ops_infer64_8.dll" "C:\Users\SEC\anaconda3\envs\pibopibo\Lib\site-packages\ctranslate2\"
```

---

#### 2. cublas64_12.dll 오류

**오류:** `Library cublas64_12.dll is not found or cannot be loaded`

**원인:** ctranslate2가 CUDA 12용 cuBLAS 요구

**해결:**
```powershell
# CUDA 12용 cuBLAS 설치
pip install nvidia-cublas-cu12

# DLL을 ctranslate2 폴더에 복사
Copy-Item "C:\Users\SEC\anaconda3\envs\pibopibo\Lib\site-packages\nvidia\cublas\bin\*.dll" "C:\Users\SEC\anaconda3\envs\pibopibo\Lib\site-packages\ctranslate2\" -Force
```

---

#### 3. DLL 경로 설정 코드 수정

**문제:** `nvidia.cublas.lib` 모듈이 존재하지 않음

**해결:** `lib` → `bin`으로 변경
```python
# 변경 전
import nvidia.cublas.lib
import nvidia.cudnn.lib
os.add_dll_directory(os.path.dirname(nvidia.cublas.lib.__file__))
os.add_dll_directory(os.path.dirname(nvidia.cudnn.lib.__file__))

# 변경 후
import nvidia.cublas.bin
import nvidia.cudnn.bin
os.add_dll_directory(os.path.dirname(nvidia.cublas.bin.__file__))
os.add_dll_directory(os.path.dirname(nvidia.cudnn.bin.__file__))
```

---

#### 4. 최종 필요 패키지 (SEC 노트북)

```powershell
pip install nvidia-cudnn-cu11==8.9.5.29
pip install nvidia-cublas-cu11
pip install nvidia-cublas-cu12
pip install huggingface_hub==0.23.5  # use_auth_token 오류 방지
```

**참고 링크:** https://github.com/SYSTRAN/faster-whisper/discussions/715

---

### 화자 분할 개선

#### 1. 첫 화자를 A로 시작하도록 수정

**문제:** 첫 화자가 C, D 등 임의의 라벨로 시작됨

**해결:** 등장 순서대로 라벨 매핑 추가
```python
# DiartSpeakerDiarization 클래스에 추가
self.speaker_order_map = {}
self.next_speaker_index = 0

def get_speaker_label(self, speaker_id=None):
    # ... (생략)
    # 새로운 화자면 등장 순서에 따라 매핑
    if speaker_id not in self.speaker_order_map:
        self.speaker_order_map[speaker_id] = self.next_speaker_index
        self.next_speaker_index += 1

    order_index = self.speaker_order_map[speaker_id]
    labels = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J"]
    return f"화자 {labels[order_index]}"
```

---

#### 2. 파라미터 조정

| 파라미터 | 변경 전 | 변경 후 | 이유 |
|----------|---------|---------|------|
| `chunk_duration` | 5.0 | 2.0 | 응답 속도와 정확도 균형 |
| `tau_active` | 0.6 | 0.5 | [미지정] 줄이기 |

---

### 실제 테스트 결과 (Jabra Speak2 75)

**테스트 환경:** SEC 노트북 + Jabra Speak2 75 마이크

**결과:** 두 사람 화자 분리 성공
```
[10:45] [화자 C] 안녕하시오.
[10:45] [화자 C] 반갑습니다.
[10:46] [화자 B] 박언니 한번 오셔서 말씀 한번 해주십시오.
[10:46] [화자 C] 안녕하세요.
...
```

**관찰:**
- 같은 사람은 같은 라벨 유지됨
- 다른 사람은 다른 라벨로 구분됨
- 일부 짧은 발화는 [미지정]으로 처리됨
- 음역대가 비슷하면 가끔 혼동 발생

---

### 성능 개선 옵션 (추후)

| 옵션 | 설명 |
|------|------|
| WeSpeaker 모델 | `pyannote/wespeaker-voxceleb-resnet34-LM` 사용 |
| chunk_duration 증가 | 3.0~5.0초로 늘리면 정확도 향상 |
| delta_new 조정 | 0.8로 낮추면 새 화자 더 잘 인식 |

---

## 현재 상태 요약

| 항목 | 상태 |
|------|------|
| SEC 노트북 실행 | ✅ 성공 |
| Jabra 마이크 테스트 | ✅ 성공 |
| 화자 분리 | ✅ 작동 (2인 테스트) |
| 웹 UI 연동 | ✅ 작동 |
| 첫 화자 A로 시작 | ✅ 수정 완료 |
